source("Estep.R")
source("Mstep.R")
source("utils.R")

# EM for 2 Gaussian ----

## Basic EM function ----
  # param: X_tild (matrix of data), y (vector of target variables),
  #        gamma_h (init of gamma), mu_h (init of means), sigma_h (init of standard dev)
  # return: final log likelihood, estimations of gamma, mu, sigma, eta and tau
moe_gaussian <- function(X_tild, y, gamma_h, mu_h, sigma_h, max_iter=5000, tolerance=1e-6) {
  log_likelihood <- numeric(max_iter)
  for (iter in 1:max_iter) {
    # Etape E (Expectation)
    E_step <- Estep(X_tild, y, gamma_h, mu_h, sigma_h)
    tau <- E_step$tau
    eta_h <- E_step$eta
    log_likelihood[iter] <- E_step$ll
    
    # Etape M (Maximization)
    M_step <- Mstep(X_tild, y, tau, eta_h, gamma_h)
    mu_h <- M_step$mu
    sigma_h <- M_step$sigma
    gamma_h_old <- gamma_h
    gamma_h <- M_step$gamma  
    # Critère d'arrêt
    if (iter > 1) {
      if (abs(log_likelihood[iter] - log_likelihood[iter-1]) < tolerance) {
        print(paste("Convergence atteinte à l'itération", iter))
        return(invisible(list(ll = log_likelihood, mu = mu_h, sigma = sigma_h, gamma = gamma_h, eta = eta_h, tau = tau)))
      }
    }
  }
  return(invisible(list(ll = log_likelihood, mu = mu_h, sigma = sigma_h, gamma = gamma_h, eta = eta_h, tau = tau)))
}

## EM with several initialization ----
  # initializations of the parameters are generated by the init_func
  # param: X_tild (matrix of data), y (vector of target variables), init_func (use to generate initial values)
  # return: the best log likelihood and the best estimations of gamma, mu, sigma, eta and tau
moe_gaussian_bis <- function(X_tild, y, init_func, max_iter=5000, tolerance=1e-6, nrep=5, G=2) {
  # Initialisation des tableaux pour stocker les résultats
  tab_log <- numeric(nrep)
  tab_gamma <- vector("list", nrep)
  tab_mu <- vector("list", nrep)
  tab_sigma <- vector("list", nrep)
  tab_tau <- vector("list", nrep)
  
  for (k in 1:nrep) {
    cat("Init numéro ", k, "\n")
    # Réinitialiser les paramètres aléatoirement pour chaque répétition
    repeat {
      init_params <- init_func(G)
      gamma_h_current <- init_params$gamma
      mu_h_current <- init_params$mu
      sigma_h_current <- init_params$sigma
      if (!any(is.na(eta_f(gamma_h_current, X_tild)))) break
    }
    
    log_likelihood <- numeric(max_iter)
    
    for (iter in 1:max_iter) {
      # Etape E (Expectation)
      E_step <- Estep(X_tild, y, gamma_h_current, mu_h_current, sigma_h_current)
      tau <- E_step$tau
      eta_h <- E_step$eta
      log_likelihood[iter] <- E_step$ll
      
      if (any(is.na(log_likelihood[iter]))) {
        warning("NA value in log likelihood", iter)
        break
      }
      if (any(colSums(eta_h)==0)) {
        warning("empty class at itereration", iter)
        break
      }
      
      # Etape M (Maximization)
      M_step <- Mstep(X_tild, y, tau, eta_h, gamma_h_current)
      mu_h_current <- M_step$mu
      sigma_h_current <- M_step$sigma
      gamma_h_old <- gamma_h_current
      gamma_h_current <- M_step$gamma  
      
      # Critère d'arrêt
      if (iter > 1) {
        if (abs(log_likelihood[iter] - log_likelihood[iter-1]) < tolerance) {
          print(paste("Convergence atteinte à l'itération", iter))
          break
        }
      }
    }
    # Stocker uniquement la dernière valeur de log_likelihood
    tab_log[k] <- log_likelihood[iter]
    tab_gamma[[k]] <- gamma_h_current
    tab_mu[[k]] <- mu_h_current
    tab_sigma[[k]] <- sigma_h_current
    tab_tau[[k]] <- tau
  }
  
  # Trouver l'index de la meilleure estimation basée sur log_likelihood
  best_index <- which.max(tab_log)
  
  # Retourner les meilleurs résultats
  return(invisible(list(
    best_log = tab_log[best_index],
    best_gamma = tab_gamma[[best_index]],
    best_mu = tab_mu[[best_index]],
    best_sigma = tab_sigma[[best_index]],
    best_tau = tab_tau[[best_index]]
  )))
}

## EM with as initial gamma parameters, the real one perturbated by a gaussian noise ----
  # param: X_tild (matrix of data), y (vector of target variables),
  #        true_gamma, mu_h (init of means), sigma_h (init of standard dev)
  # return: final log likelihood, estimations of gamma, mu, sigma, eta and tau
moe_gaussian_var <- function(X_tild, y, true_gamma, mu_h, sigma_h, max_iter=5000, tolerance=1e-6, G=2, q=3) {
  perturbation <- matrix(rnorm(q*(G-1), mean = 0, sd = 2), ncol=G-1)
  gamma_h <- matrix(rep(0, G*q), ncol = G)
  gamma_h[, 2:G] <- true_gamma[, 2:G] + perturbation
  print(gamma_h)
  cat('\n')
  return(moe_gaussian(X_tild, y, gamma_h, mu_h, sigma_h, max_iter=max_iter, tolerance=tolerance))
}

## gausian final ----
moe_gaussian_final <- function(X_tild, y, G, max_iter=5000, tolerance=1e-6, q=3) {
  init <- init_param(X_tild, y, G)
  return(moe_gaussian(X_tild, y, init$gamma, init$m_h, init$sigma_h, max_iter=max_iter, tolerance=tolerance))
}

# Standard model ----
moe_stand <- function(X_tild, y, gamma_h, beta_h, sigma_h, max_iter = 5000, tolerance = 1e-6) {
  log_likelihood <- numeric(max_iter)
  tau_prev <- NULL
  
  for (iter in 1:max_iter) {
    # Etape E (Expectation)
    E_step <- tryCatch({
      Estep_stand(X_tild, y, gamma_h, beta_h, sigma_h)
    }, error = function(e) {
      cat("Erreur dans l'étape E, itération ", iter)
      print(list(X_tild = X_tild, y = y, gamma_h = gamma_h, beta_h = beta_h, sigma_h = sigma_h, tau_prev = tau_prev))
      stop(e)
    })
    
    tau <- E_step$tau
    eta_h <- E_step$eta
    log_likelihood[iter] <- E_step$ll
    
    # Etape M (Maximization)
    M_step <- tryCatch({
      Mstep_stand(X_tild, y, tau, eta_h, gamma_h)
    }, error = function(e) {
      print("Erreur dans l'étape M:")
      print(list(X_tild = X_tild, y = y, tau = tau, eta_h = eta_h, gamma_h = gamma_h, tau_prev = tau_prev))
      stop(e)
    })
    
    beta_h <- M_step$beta
    sigma_h <- M_step$sigma
    gamma_h <- M_step$gamma  
    
    # Mise à jour du tau précédent
    tau_prev <- tau
    
    # Critère d'arrêt
    if (iter > 1) {
      if (abs(log_likelihood[iter] - log_likelihood[iter-1]) < tolerance) {
        print(paste("Convergence atteinte à l'itération", iter))
        return(invisible(list(ll = log_likelihood, beta = beta_h, sigma = sigma_h, gamma = gamma_h, eta = eta_h, tau = tau, tau_prev = tau_prev)))
      }
    }
  }
  
  return(invisible(list(ll = log_likelihood, beta = beta_h, sigma = sigma_h, gamma = gamma_h, eta = eta_h, tau = tau, tau_prev = tau_prev)))
}

moe_stand_final <- function(X_tild, y, G, max_iter = 5000, tolerance = 1e-6, q = 3) {
  init <- init_param_stand(X_tild, y, G)
  return(moe_stand(X_tild, y, init$gamma, init$beta, init$sigma, max_iter = max_iter, tolerance = tolerance))
}


# Old functions --------------

moe_gaussian_bis_old <- function(X_tild, y, init_func, max_iter=5000, tolerance=1e-6, nrep=5) {
  # Initialisation des tableaux pour stocker les résultats
  tab_log <- numeric(nrep)
  tab_gamma <- vector("list", nrep)
  tab_mu <- vector("list", nrep)
  tab_sigma <- vector("list", nrep)
  
  for (k in 1:nrep) {
    cat("Init numéro ", k)
    # Réinitialiser les paramètres aléatoirement pour chaque répétition
    repeat {
      init_params <- init_func()
      gamma_h_current <- init_params$gamma
      mu_h_current <- init_params$mu
      sigma_h_current <- init_params$sigma
      if (!any(is.na(eta_f(gamma_h_current, X_tild)))) break
    }
    
    log_likelihood <- numeric(max_iter)
    
    for (iter in 1:max_iter) {
      # Etape E (Expectation)
      E_step <- Estep(X_tild, y, gamma_h_current, mu_h_current, sigma_h_current)
      tau <- E_step$tau
      eta_h <- E_step$eta
      log_likelihood[iter] <- E_step$ll
      
      # Vérification des valeurs NA dans log_likelihood
      if (is.na(log_likelihood[iter])) {
        # renvoyer une erreur si une classe vide
        # structurer le codes dans plusieurs fichiers
        # 
        warning("NA detected in log_likelihood at iteration ", iter, 
                "\nInit number: ", k, 
                "\ngamma_h_current: ", gamma_h_current, 
                "\nmu_h_current: ", mu_h_current, 
                "\nsigma_h_current: ", sigma_h_current, 
                "\ntau: ", tau, 
                "\neta_h: ", eta_h)
        return(invisible(list(
          gamma_h_current = gamma_h_current,
          mu_h_current = mu_h_current,
          sigma_h_current = sigma_h_current,
          tau = tau,
          eta_h = eta_h,
          log_likelihood = log_likelihood[1:iter]
        )))
      }
      
      # Etape M (Maximization)
      M_step <- Mstep(X_tild, y, tau, eta_h, gamma_h_current)
      mu_h_current <- M_step$mu
      sigma_h_current <- M_step$sigma
      gamma_h_old <- gamma_h_current
      gamma_h_current <- M_step$gamma  
      
      # Critère d'arrêt
      if (iter > 1) {
        if (abs(log_likelihood[iter] - log_likelihood[iter-1]) < tolerance) {
          print(paste("Convergence atteinte à l'itération", iter))
          break
        }
      }
    }
    # Stocker uniquement la dernière valeur de log_likelihood
    tab_log[k] <- log_likelihood[iter]
    tab_gamma[[k]] <- gamma_h_current
    tab_mu[[k]] <- mu_h_current
    tab_sigma[[k]] <- sigma_h_current
  }
  
  # Trouver l'index de la meilleure estimation basée sur log_likelihood
  best_index <- which.max(tab_log)
  
  # Retourner les meilleurs résultats
  return(invisible(list(
    best_log = tab_log[best_index],
    best_gamma = tab_gamma[[best_index]],
    best_mu = tab_mu[[best_index]],
    best_sigma = tab_sigma[[best_index]]
  )))
}
